<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MFE Dubbing Quality Survey</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="config.js"></script>
    <script type="text/babel">
      const { useState, useEffect, useCallback } = React;

      const STORAGE_KEY_PREFIX = 'mfe-survey-progress::';
      const SURVEY_CONFIG = window.SURVEY_CONFIG || { userCodes: [], videos: [] };

      const getStorageKey = (code) => `${STORAGE_KEY_PREFIX}${code}`;

      function getBrowserStorage() {
        try {
          const testKey = `${STORAGE_KEY_PREFIX}check`;
          window.localStorage.setItem(testKey, 'test');
          window.localStorage.removeItem(testKey);
          return window.localStorage;
        } catch (error) {
          console.warn('Local storage is not available', error);
          return null;
        }
      }

      function normalizeRecord(input) {
        const base = { responses: {}, completed: false, completedAt: null };
        if (!input || typeof input !== 'object') {
          return base;
        }
        const responses = {};
        Object.entries(input.responses || {}).forEach(([videoId, entry]) => {
          if (!entry || typeof entry !== 'object') {
            return;
          }
          const rating = Number(entry.qualityRating);
          if (!Number.isInteger(rating) || typeof entry.isAi !== 'boolean') {
            return;
          }
          responses[videoId] = {
            isAi: entry.isAi,
            qualityRating: rating,
            savedAt: entry.savedAt || entry.timestamp || null
          };
        });
        const completedAt =
          typeof input.completedAt === 'string' && input.completedAt ? input.completedAt : null;
        return {
          responses,
          completed: Boolean(input.completed),
          completedAt
        };
      }

      const LoadingScreen = () => (
        <div className="status-card" role="status" aria-live="polite">
          <div className="loader" />
          <h2>Loading the survey…</h2>
          <p>Please hold on while we prepare your personalized experience.</p>
        </div>
      );

      const ErrorScreen = ({ message }) => (
        <div className="status-card" role="alert">
          <img src="assets/mfe-logo.svg" alt="MFE logo" width="96" height="96" />
          <h2>We can’t open the survey</h2>
          <p>{message}</p>
        </div>
      );

      const WelcomeScreen = ({ onStart, hasProgress, totalVideos }) => (
        <div className="welcome-card">
          <img src="assets/mfe-logo.svg" alt="MFE logo" />
          <h1>Welcome to the MFE Dubbing Quality Study</h1>
          <p>
            Thank you for helping the Media for Everyone initiative evaluate AI-dubbed experiences.
            You’ll watch {totalVideos} short video clips and answer two quick questions about each
            one. Your answers stay on this device until you download them at the end.
          </p>
          <button className="primary-button" onClick={onStart}>Start survey</button>
          {hasProgress && (
            <div className="header-badge">
              <img src="assets/mfe-logo.svg" alt="" aria-hidden="true" />
              <span>Your previous answers have been saved. Click start to resume.</span>
            </div>
          )}
        </div>
      );

      const SurveyScreen = ({
        video,
        index,
        total,
        selectedIsAi,
        onSelectIsAi,
        selectedRating,
        onSelectRating,
        onBack,
        onNext,
        canProceed,
        canGoBack,
        inlineError
      }) => {
        if (!video) {
          return null;
        }

        const yesId = `is-ai-yes-${video.id}`;
        const noId = `is-ai-no-${video.id}`;

        return (
          <div className="survey-container">
            <div className="video-column">
              <p className="progress-label">Video {index + 1}/{total}</p>
              <div className="video-wrapper">
                <video controls src={video.url} aria-label={video.title || `Video ${index + 1}`} />
              </div>
              {video.title && <p className="video-title">{video.title}</p>}
            </div>
            <div className="questions-column">
              <h2>Share your verdict</h2>
              <div className="question-block">
                <fieldset>
                  <legend>Is this video AI-generated?</legend>
                  <div className="option-group">
                    <label className={`option-card ${selectedIsAi === true ? 'selected' : ''}`} htmlFor={yesId}>
                      <input
                        type="radio"
                        id={yesId}
                        name="is-ai"
                        value="yes"
                        checked={selectedIsAi === true}
                        onChange={() => onSelectIsAi(true)}
                      />
                      <span>Yes</span>
                    </label>
                    <label className={`option-card ${selectedIsAi === false ? 'selected' : ''}`} htmlFor={noId}>
                      <input
                        type="radio"
                        id={noId}
                        name="is-ai"
                        value="no"
                        checked={selectedIsAi === false}
                        onChange={() => onSelectIsAi(false)}
                      />
                      <span>No</span>
                    </label>
                  </div>
                </fieldset>
              </div>
              <div className="question-block">
                <fieldset className="star-fieldset">
                  <legend>Rate the quality</legend>
                  <div className="star-rating" role="radiogroup" aria-label="Rate the quality from 1 to 5 stars">
                    {[1, 2, 3, 4, 5].map((num) => {
                      const ratingId = `quality-${video.id}-${num}`;
                      return (
                        <div className="star-option" key={ratingId}>
                          <input
                            type="radio"
                            id={ratingId}
                            name="quality-rating"
                            value={num}
                            checked={Number(selectedRating) === num}
                            onChange={() => onSelectRating(num)}
                          />
                          <label htmlFor={ratingId} aria-label={`${num} star${num > 1 ? 's' : ''}`}>
                            <span aria-hidden="true">{`${num}★`}</span>
                          </label>
                        </div>
                      );
                    })}
                  </div>
                  <p className="rating-hint">Use the arrow keys or number keys to choose a rating.</p>
                </fieldset>
              </div>
              {inlineError && (
                <div className="error-banner" role="alert">
                  {inlineError}
                </div>
              )}
              <div className="navigation-row">
                <button
                  type="button"
                  className="secondary-button"
                  onClick={onBack}
                  disabled={!canGoBack}
                >
                  Back
                </button>
                <button type="button" className="primary-button" onClick={onNext} disabled={!canProceed}>
                  Next
                </button>
              </div>
            </div>
          </div>
        );
      };

      const ConfirmationScreen = ({
        answeredCount,
        total,
        onSubmit,
        onReview,
        submitting,
        submitStatus,
        onDownload,
        exportStatus,
        exportMessage
      }) => (
        <div className="confirmation-card">
          <img src="assets/mfe-logo.svg" alt="MFE logo" width="120" height="120" />
          <h2>{submitStatus === 'done' ? 'Submission received!' : 'Ready to submit'}</h2>
          <p>
            {submitStatus === 'done'
              ? 'Thank you for completing the study. Your responses are saved on this device. Use the download button below to share them.'
              : `You have reviewed ${answeredCount} out of ${total} videos. Submit to lock in your responses and enable the download option.`}
          </p>
          <div className="confirmation-actions">
            {submitStatus !== 'done' && (
              <button className="secondary-button" type="button" onClick={onReview}>
                Review videos
              </button>
            )}
            <button
              className="primary-button"
              type="button"
              onClick={onSubmit}
              disabled={submitting || submitStatus === 'done'}
            >
              {submitStatus === 'done' ? 'Submitted' : submitting ? 'Submitting…' : 'Submit'}
            </button>
            {submitStatus === 'done' && (
              <button className="secondary-button" type="button" onClick={onDownload}>
                Download responses
              </button>
            )}
          </div>
          {submitStatus === 'done' && (
            <div className="success-banner" role="status" aria-live="polite">
              <p>All set! Your responses are stored on this device.</p>
              <p>Use the download button to export a CSV copy.</p>
              {exportStatus === 'success' && exportMessage && <p>{exportMessage}</p>}
            </div>
          )}
          {exportStatus === 'error' && exportMessage && (
            <div className="error-banner" role="alert">{exportMessage}</div>
          )}
        </div>
      );

      const FooterNote = () => (
        <p className="footer-note">
          Need help? Contact your MFE coordinator with your invitation code.
        </p>
      );

      function App() {
        const storageRef = React.useRef(null);

        const [status, setStatus] = useState('loading');
        const [fatalError, setFatalError] = useState('');
        const [view, setView] = useState('welcome');
        const [videos, setVideos] = useState([]);
        const [answers, setAnswers] = useState({});
        const [currentIndex, setCurrentIndex] = useState(0);
        const [selectedIsAi, setSelectedIsAi] = useState(null);
        const [selectedRating, setSelectedRating] = useState(null);
        const [inlineError, setInlineError] = useState('');
        const [hasProgress, setHasProgress] = useState(false);
        const [submitting, setSubmitting] = useState(false);
        const [submitStatus, setSubmitStatus] = useState('idle');
        const [userCode, setUserCode] = useState('');
        const [exportStatus, setExportStatus] = useState('idle');
        const [exportMessage, setExportMessage] = useState('');

        const readRecord = useCallback((code) => {
          const storage = storageRef.current;
          if (!storage || !code) {
            return { responses: {}, completed: false, completedAt: null };
          }
          try {
            const raw = storage.getItem(getStorageKey(code));
            return normalizeRecord(raw ? JSON.parse(raw) : null);
          } catch (error) {
            console.error('Unable to read stored responses', error);
            return { responses: {}, completed: false, completedAt: null };
          }
        }, []);

        const updateStoredAnswers = useCallback(
          (code, nextAnswers, overrides = {}) => {
            const storage = storageRef.current;
            if (!storage || !code) {
              return null;
            }
            try {
              const current = readRecord(code);
              const record = normalizeRecord({
                responses: nextAnswers,
                completed:
                  overrides.completed !== undefined ? overrides.completed : current.completed,
                completedAt:
                  overrides.completedAt !== undefined
                    ? overrides.completedAt
                    : current.completedAt
              });
              storage.setItem(getStorageKey(code), JSON.stringify(record));
              return record;
            } catch (error) {
              console.error('Unable to store survey progress', error);
              return null;
            }
          },
          [readRecord]
        );

        useEffect(() => {
          const storage = getBrowserStorage();
          if (!storage) {
            setFatalError(
              'This survey requires access to local storage. Please enable it in your browser and reload the page.'
            );
            setStatus('error');
            return;
          }
          storageRef.current = storage;

          if (!SURVEY_CONFIG || typeof SURVEY_CONFIG !== 'object') {
            setFatalError('The survey configuration could not be loaded. Please check config.js.');
            setStatus('error');
            return;
          }

          const params = new URLSearchParams(window.location.search);
          const code = params.get('uid');
          if (!code) {
            setFatalError(
              'A survey code is required. Please contact the organizer for your personalized link.'
            );
            setStatus('error');
            return;
          }
          const trimmedCode = code.trim();
          if (!trimmedCode) {
            setFatalError(
              'A survey code is required. Please contact the organizer for your personalized link.'
            );
            setStatus('error');
            return;
          }

          const normalizedCodes = Array.isArray(SURVEY_CONFIG.userCodes)
            ? SURVEY_CONFIG.userCodes
                .filter((item) => typeof item === 'string')
                .map((item) => item.trim())
                .filter(Boolean)
            : [];

          if (!normalizedCodes.includes(trimmedCode)) {
            setFatalError('Invalid or expired code. Please contact the organizer.');
            setStatus('error');
            return;
          }

          const safeVideos = Array.isArray(SURVEY_CONFIG.videos)
            ? SURVEY_CONFIG.videos.filter(
                (video) =>
                  video &&
                  typeof video.id === 'string' &&
                  video.id.trim() &&
                  typeof video.url === 'string' &&
                  video.url.trim()
              )
            : [];

          if (safeVideos.length === 0) {
            setFatalError('No survey videos are configured. Please update config.js before sharing the survey.');
            setStatus('error');
            return;
          }

          setUserCode(trimmedCode);
          setVideos(safeVideos);

          const existingRecord = readRecord(trimmedCode);
          const restoredAnswers = {};
          safeVideos.forEach((video) => {
            const stored = existingRecord.responses[video.id];
            if (!stored) {
              return;
            }
            const rating = Number(stored.qualityRating);
            if (!Number.isInteger(rating) || typeof stored.isAi !== 'boolean') {
              return;
            }
            restoredAnswers[video.id] = {
              isAi: stored.isAi,
              qualityRating: rating,
              savedAt: stored.savedAt || null
            };
          });

          setAnswers(restoredAnswers);
          setHasProgress(Object.keys(restoredAnswers).length > 0);

          const firstIncompleteIndex = safeVideos.findIndex((video) => !restoredAnswers[video.id]);
          const defaultIndex =
            firstIncompleteIndex === -1 ? Math.max(safeVideos.length - 1, 0) : firstIncompleteIndex;
          setCurrentIndex(defaultIndex);

          if (existingRecord.completed) {
            setSubmitStatus('done');
            setView('confirmation');
          } else if (firstIncompleteIndex === -1 && safeVideos.length > 0) {
            setView('confirmation');
          } else {
            setView('welcome');
          }

          setExportStatus('idle');
          setExportMessage('');
          setStatus('ready');
        }, [readRecord]);

        useEffect(() => {
          if (view !== 'survey') {
            return;
          }
          const activeVideo = videos[currentIndex];
          if (!activeVideo) {
            return;
          }
          const existing = answers[activeVideo.id];
          setSelectedIsAi(existing ? existing.isAi : null);
          setSelectedRating(existing ? existing.qualityRating : null);
          setInlineError('');
        }, [view, currentIndex, videos, answers]);

        const answeredCount = videos.reduce(
          (total, video) => (answers[video.id] ? total + 1 : total),
          0
        );
        const allAnswered = videos.length > 0 && answeredCount === videos.length;

        const handleStart = () => {
          if (allAnswered || submitStatus === 'done') {
            setView('confirmation');
            return;
          }
          setInlineError('');
          setExportStatus('idle');
          setExportMessage('');
          setView('survey');
        };

        const handleSelectIsAi = (value) => {
          setSelectedIsAi(value);
          setInlineError('');
        };

        const handleSelectRating = (value) => {
          setSelectedRating(value);
          setInlineError('');
        };

        const handleBack = () => {
          if (currentIndex === 0) {
            return;
          }
          setCurrentIndex((prev) => Math.max(prev - 1, 0));
        };

        const handleSaveAndNext = () => {
          const activeVideo = videos[currentIndex];
          if (!activeVideo) {
            return;
          }
          if (selectedIsAi === null || selectedRating === null) {
            setInlineError('Please answer both questions before continuing.');
            return;
          }

          const savedAt = new Date().toISOString();
          const nextAnswers = {
            ...answers,
            [activeVideo.id]: {
              isAi: selectedIsAi,
              qualityRating: selectedRating,
              savedAt
            }
          };

          const storedRecord = updateStoredAnswers(userCode, nextAnswers);
          if (!storedRecord) {
            setInlineError(
              'We could not save your answers on this device. Please check your browser settings and try again.'
            );
            return;
          }

          setAnswers(nextAnswers);
          setHasProgress(Object.keys(nextAnswers).length > 0);
          setInlineError('');
          setExportStatus('idle');
          setExportMessage('');

          if (currentIndex + 1 < videos.length) {
            setCurrentIndex((prev) => prev + 1);
          } else {
            setView('confirmation');
          }
        };

        const handleSubmit = () => {
          if (submitStatus === 'done') {
            return;
          }
          if (!allAnswered) {
            setInlineError('Please answer all videos before submitting.');
            return;
          }

          setSubmitting(true);
          setInlineError('');

          const completedAt = new Date().toISOString();
          const storedRecord = updateStoredAnswers(userCode, answers, {
            completed: true,
            completedAt
          });

          if (!storedRecord) {
            setInlineError(
              'We could not finalize your survey. Please ensure local storage is enabled and try again.'
            );
            setSubmitting(false);
            return;
          }

          setSubmitStatus('done');
          setSubmitting(false);
          setExportStatus('idle');
          setExportMessage('');
        };

        const handleReview = () => {
          if (videos.length === 0) {
            return;
          }
          setView('survey');
          setInlineError('');
          setExportStatus('idle');
          setExportMessage('');
        };

        const handleDownload = useCallback(() => {
          if (!userCode) {
            return;
          }

          setExportStatus('idle');
          setExportMessage('');

          const record = readRecord(userCode);
          const answeredRows = videos
            .map((video) => {
              const entry = answers[video.id];
              if (!entry) {
                return null;
              }
              return {
                videoId: video.id,
                isAi: entry.isAi,
                qualityRating: entry.qualityRating,
                savedAt: entry.savedAt || ''
              };
            })
            .filter(Boolean);

          if (answeredRows.length === 0) {
            setExportStatus('error');
            setExportMessage('There are no saved responses to download yet.');
            return;
          }

          const completionTimestamp =
            record.completedAt || (record.completed ? new Date().toISOString() : '');
          const userAgent = navigator.userAgent || '';
          const header = [
            'user_code',
            'video_id',
            'is_ai',
            'quality_rating',
            'timestamp',
            'user_agent',
            'completed_at'
          ];
          const csvRows = answeredRows.map((row) => [
            userCode,
            row.videoId,
            row.isAi,
            row.qualityRating,
            row.savedAt,
            userAgent,
            completionTimestamp
          ]);
          const csv = [header, ...csvRows]
            .map((row) =>
              row
                .map((value) => {
                  const stringValue =
                    value === undefined || value === null ? '' : String(value);
                  const escaped = stringValue.replace(/"/g, '""');
                  return `"${escaped}"`;
                })
                .join(',')
            )
            .join('\n');

          try {
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const anchor = document.createElement('a');
            anchor.href = url;
            anchor.download = `${userCode}-survey-responses.csv`;
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);
            URL.revokeObjectURL(url);
            setExportStatus('success');
            setExportMessage('Responses downloaded as CSV. Share this file with the organizer.');
          } catch (error) {
            console.error('Failed to prepare download', error);
            setExportStatus('error');
            setExportMessage('We could not download your responses. Please try again.');
          }
        }, [answers, readRecord, userCode, videos]);

        return (
          <div className="app-shell">
            <main className="content-area">
              {status === 'loading' && <LoadingScreen />}
              {status === 'error' && <ErrorScreen message={fatalError} />}
              {status === 'ready' && view === 'welcome' && (
                <WelcomeScreen
                  onStart={handleStart}
                  hasProgress={hasProgress}
                  totalVideos={videos.length}
                />
              )}
              {status === 'ready' && view === 'survey' && (
                <SurveyScreen
                  video={videos[currentIndex]}
                  index={currentIndex}
                  total={videos.length}
                  selectedIsAi={selectedIsAi}
                  onSelectIsAi={handleSelectIsAi}
                  selectedRating={selectedRating}
                  onSelectRating={handleSelectRating}
                  onBack={handleBack}
                  onNext={handleSaveAndNext}
                  canProceed={selectedIsAi !== null && selectedRating !== null}
                  canGoBack={currentIndex > 0}
                  inlineError={inlineError}
                />
              )}
              {status === 'ready' && view === 'confirmation' && (
                <ConfirmationScreen
                  answeredCount={answeredCount}
                  total={videos.length}
                  onSubmit={handleSubmit}
                  onReview={handleReview}
                  submitting={submitting}
                  submitStatus={submitStatus}
                  onDownload={handleDownload}
                  exportStatus={exportStatus}
                  exportMessage={exportMessage}
                />
              )}
            </main>
            {status === 'ready' && <FooterNote />}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
